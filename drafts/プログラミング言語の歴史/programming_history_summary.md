# プログラミング言語史概要

## はじめに
この文書は、プログラミング言語の歴史を社会的・技術的背景とともに体系的に学ぶための要約です。各言語がなぜ生まれたのか、どのような問題を解決するために開発されたのかを時代背景と合わせて理解できます。

## 初期の計算機械（15-19世紀）

### パスカリーヌの発明（17世紀）
- **背景**: 税金徴収業務の効率化が必要
- **発明者**: パスカル（フランス）
- **意義**: 現存する最古の計算機、コンピュータの語源

### チャールズ・バベッジの解析機関（1837年）
- **背景**: 船の位置計算などの数表作成需要
- **技術**: パンチカードシステム
- **重要人物**: エイダ・ラブレース - 人類初のプログラマー
- **意義**: プログラムコードという概念の誕生

## 第二次世界大戦期の技術革命（1940年代）

### 暗号解読とコンピュータの発明
- **背景**: ドイツのエニグマ暗号解読の必要性
- **チューリングマシン**: アラン・チューリング（イギリス）
- **ENIAC**: ジョン・フォン・ノイマン（アメリカ）- 世界初のプログラム可能汎用電子計算機

## 第一世代言語の誕生（1950年代）

### FORTRAN（1954年）
- **開発者**: ジョン・バッカス（IBM）
- **背景**: 科学技術計算の効率化
- **意義**: 現在でも使われる最初の高水準言語

### ALGOL58/60（1958-1960年）
- **背景**: ヨーロッパの研究者による国際協力
- **技術革新**: 構造化プログラミング（begin-end、if、for）

### LISP（1960年頃）
- **背景**: 数学者による理論的なアプローチ
- **特徴**: 数学記法ベース、理論重視の設計

### COBOL（1960年頃）
- **開発者**: グレース・ホッパー（アメリカ海軍）
- **背景**: 自然な英語でのプログラミング実現
- **用途**: 事務処理用途

## 言語世代の進化（1960年代）

### 世代分類の確立
- **第1世代**: 機械語
- **第2世代**: アセンブリ言語
- **第3世代**: FORTRAN、ALGOL、LISP、COBOL
- **第4世代**: RPG（人間の言葉により近い）

### 教育・汎用言語の登場
- **BASIC**: ダートマス大学（学生向けの簡易言語）
- **PL/I**: FORTRAN と COBOL の統合を目指す

## オブジェクト指向の概念誕生（1960年代後半）

### SIMULA（ノルウェー）
- **意義**: 初めて「オブジェクト」という概念を導入
- **影響**: 後のオブジェクト指向言語の基礎

### CPL、BCPL（イギリス）
- **技術革新**: 波括弧（{}）による構文の導入

## 宇宙開発とプログラミング（1969年）

### アポロ11号月面着陸
- **地上支援**: IBMの高性能マシンとFORTRAN/COBOL
- **宇宙船**: あえて低性能なコンピュータを使用（信頼性重視）

## ネットワーク時代の始まり（1970年代）

### インターネットの前身
- **ARPANET**: アメリカ東西をつなぐネットワーク
- **背景**: 軍事的連携の必要性

### 伝説の言語Cの誕生（1970年代初期）
- **開発者**: デニス・リッチー（ベル研究所）
- **背景**: UNIXオペレーティングシステムの開発需要
- **技術基盤**: ケン・トンプソンのB言語から発展
- **普及の理由**: UNIXの普及とともに拡散

### Pascal（スイス）
- **由来**: パスカルの名前から
- **特徴**: シンプルで万能、Cと人気を二分

## オブジェクト指向の発展（1970年代）

### Smalltalk（ゼロックス社）
- **背景**: SIMULA、LISPの考え方を統合
- **革新**: オブジェクト指向プログラミングの確立

### Prolog（フランス）
- **開発者**: アラン・カルメラウアー
- **用途**: 人工知能・言語処理分野

### ML（イギリス）
- **開発者**: ロビン・ミルナー
- **用途**: 数学の証明支援

## パーソナルコンピュータ革命（1970年代後半）

### マイクロソフトの設立
- **創設者**: ビル・ゲイツとポール・アレン
- **きっかけ**: BASIC言語の関連ソフト開発成功

### Appleの設立
- **創設者**: スティーブ・ジョブズとスティーブ・ウォズニアック
- **目標**: 一般家庭向けパソコンの普及

## プログラミング言語の専門化（1980年代）

### Ada（1980年代初期）
- **背景**: アメリカ国防総省の信頼性高い言語への需要
- **命名**: 最初のプログラマー、エイダの名前から
- **用途**: 飛行機制御システムなど

### C++の誕生（1980年代中期）
- **開発者**: ビャーネ・ストロヴストルップ（ベル研究所）
- **背景**: Cにオブジェクト指向機能を追加
- **革新**: 既存のCコードとの互換性を保持

### Objective-C
- **開発者**: ブラッド・コックス
- **アプローチ**: SmalltalkとCの融合
- **特徴**: C++と共存可能な設計

### MATLAB（1984年）
- **開発者**: クリーブ・モラー（スタンフォード大学）
- **背景**: 学生向けの数値計算・データ可視化
- **普及**: 教育現場での広範な採用

## GUI時代の到来（1980年代中後期）

### グラフィカルユーザーインターフェース（GUI）の普及
- **Apple Macintosh**: ハードウェア+OS セット販売
- **Microsoft Windows**: OS単体販売
- **背景**: CUI（文字ベース）からGUI（グラフィック）への移行

### Object Pascal の発展
- **Turbo Pascal**: ボーランド社の開発環境
- **複雑な変遷**: Apple版 → Delphi → Object Pascal への名称変化

## スクリプト言語の台頭（1980年代後期-1990年代）

### Perl（1980年代後期）
- **開発者**: ラリー・ウォール（アメリカ）
- **特徴**: 開発スピード重視、C言語の複雑な処理を簡素化
- **トレードオフ**: 実行速度より開発効率を優先

### 冷戦終結の影響（1991年）
- **ベルリンの壁崩壊**: 東西技術交流の活発化
- **Linux の誕生**: リーナス・トーバルズ（フィンランド）によるオープンソースOS

### Python（1991年）
- **開発者**: グイド・ヴァン・ロッサム（オランダ）
- **設計思想**: "Simple is Best" - コードの統一性重視
- **対比**: Perlとは対照的なアプローチ

### Visual Basic/VBA
- **背景**: Windowsアプリケーション開発の需要
- **特徴**: 用途特化型言語への流れ

## World Wide Web の誕生（1990年代初期）

### HTML の発明（1990年代初期）
- **発明者**: ティム・バーナーズ＝リー（CERN）
- **背景**: インターネット上でのページ公開システム
- **哲学**: 特許を取得せず、誰でも自由に使用可能

### R言語（ニュージーランド）
- **背景**: S言語の模倣とオープンソース化
- **用途**: 研究分野での統計処理

### Lua（ブラジル）
- **背景**: ゲームエンジンとの連携需要
- **特徴**: 組み込み用途に特化

## 第一次ブラウザ戦争（1990年代中期）

### Netscape Navigator vs Internet Explorer
- **Netscape**: 市場先行者の優位
- **Microsoft**: Windows95 との同梱戦略
- **結果**: IEの勝利（Windows95の大ヒット）

### Java の革命（1995年）
- **開発者**: ジェームズ・ゴスリン（Sun Microsystems）
- **革新**: JVM（Java Virtual Machine）による機種非依存性
- **スローガン**: "Write once, run anywhere"

### JavaScript の複雑な誕生
- **Netscape**: LiveScript → JavaScript（Java人気にあやかり改名）
- **Microsoft**: JScript（IE用）
- **標準化**: ECMAScript による共通ルール策定

## サーバーサイド技術の発展（1990年代中後期）

### PHP の誕生
- **開発者**: ラスマス・ラードフ（カナダ）
- **背景**: Web専用言語の需要
- **発展**: PHP/FI → PHP

### LAMP環境の完成
- **構成**: Linux + Apache + MySQL + PHP/Python/Perl
- **意義**: オープンソースによる完全なWeb開発環境

### Ruby（1995年）
- **開発者**: まつもとゆきひろ（日本）
- **設計思想**: プログラマーの楽しさを最優先
- **特徴**: 徹底的なオブジェクト指向設計

## Y2K問題とミレニアム（1999-2000年）

### 2000年問題
- **背景**: COBOL/FORTRANの古いシステムで西暦を2桁で記録
- **懸念**: 2000年 → 1900年と誤認識される危険性
- **結果**: 大きな事故は発生せず

## 新世紀のプログラミング言語（2000年代）

### GPU とグラフィック専用言語
- **背景**: ディスプレイ高画質化、GPU普及
- **用途**: 3Dグラフィック処理専用

### D言語（アメリカ）
- **目的**: C言語の30年ぶりの置き換え
- **言語名**: B → C → D のアルファベット順

### C#（マイクロソフト）
- **開発者**: アンダース・ヘルスバーグ（元Delphi作者）
- **背景**: Java対抗言語の必要性
- **由来**: C++ → C++++ → C#

## Web 2.0 時代（2000年代中期）

### フレームワークの登場
- **Ruby on Rails**: デイヴィッド・ハンソン（デンマーク）
- **Django**: Python製（オランダ）
- **背景**: Web開発の効率化・標準化

### JVM言語の多様化
- **Groovy**（イギリス）
- **Scala**（スイス）
- **背景**: 既存のJVMインフラの活用

## ゲーム開発の民主化（2000年代中後期）

### Unity の登場
- **開発**: Over the Edge Entertainment（デンマーク）
- **革新**: 複数言語サポート（C#、UnityScript、Boo）
- **後の統一**: C#のみに収束

## 第二次ブラウザ戦争（2000年代後期）

### 新たな参戦者
- **Firefox**: Mozilla（元Netscape、オープンソース）
- **Safari**: Apple
- **Opera**: 長年待機していた選択肢
- **Chrome**: Google（2008年参戦）

### ECMAScript の対立
- **革新派**: Adobe、Mozilla、Opera、Google
- **保守派**: Microsoft、Yahoo
- **結果**: 大幅変更は見送り、JavaScript進化停滞

## スマートフォン革命（2007年）

### iPhone の衝撃
- **OS**: Unix → NeXTSTEP → OS X → iPhone OS → iOS
- **開発言語**: Objective-C継続採用
- **影響**: モバイルアプリ開発の巨大市場創出

### Android の対応
- **Google戦略**: OS単体提供（Appleのセット販売に対抗）
- **ベース**: Linux
- **開発言語**: Java採用

## 暗号通貨とブロックチェーン（2008年）

### Bitcoin の誕生
- **開発者**: サトシ・ナカモト（正体不明）
- **実装**: C++
- **技術**: ブロックチェーン技術の実用化

## 現代的言語の発展（2009-2010年代）

### Go言語（Google）
- **開発者**: ロバート・グリースマ、ロブ・パイク、ケン・トンプソン
- **背景**: C++への不満、並行処理の必要性
- **用途**: サーバーサイド開発

### Node.js の革新
- **開発者**: ライアン・ダール（カナダ）
- **技術**: V8エンジンをブラウザ外で実行
- **影響**: JavaScript のサーバーサイド進出

### NoSQL とModern Web Stack
- **MongoDB**: JSON形式のデータベース
- **MEAN/MERN Stack**: JavaScript統一環境
  - MongoDB + Express + Angular/React + Node.js

## AltJS の時代（2010年代前期）

### CoffeeScript
- **開発者**: ジェレミー・アシュケナス
- **目的**: Ruby風の文法でJavaScript生成

### Dart（Google）
- **戦略**: JavaScript完全置き換え狙い
- **結果**: 当初は「学ぶ価値がない言語1位」

### TypeScript（Microsoft）
- **開発者**: アンダース・ヘルスバーグ
- **戦略**: JavaScriptとの互換性重視
- **成功要因**: 既存コードを活かす控えめなアプローチ

## クラウドとマイクロサービス（2010年代中期）

### クラウドコンピューティングの普及
- **提供者**: Amazon、Microsoft、Google
- **影響**: インフラ管理の簡素化

### Docker とマイクロサービス
- **技術**: コンテナ化技術
- **アーキテクチャ**: モノリシック vs マイクロサービス
- **受益言語**: Go、Java（Spring Boot）

## モバイル開発言語の進化（2014-2015年）

### Swift（Apple）
- **開発者**: クリス・ラトナー
- **背景**: Objective-C の老朽化
- **技術**: LLVM の活用

### Kotlin（JetBrains）
- **背景**: Android開発でのJava代替
- **戦略**: 既存Java開発者の置き去り回避
- **採用**: Google公式採用（2017年）

## システムプログラミング言語の挑戦（2015年）

### Rust（Mozilla）
- **目的**: C/C++の安全な代替
- **背景**: ブラウザ戦争で得たノウハウ活用
- **特徴**: メモリ安全性とパフォーマンスの両立

### Zig
- **ポジション**: Rustへの対抗

## JavaScript の復権（2015年）

### ECMAScript 2015
- **経緯**: 各社の意見統一、大幅アップデート
- **影響**:
  - CoffeeScript の衰退
  - Dart の失敗確定
  - TypeScript の一人勝ち

## 第三次AI ブーム（2015年以降）

### 深層学習の実用化
- **応用**: 画像認識、ゲームAI（チェス、囲碁）
- **主要言語**: Python の完全支配

### Web開発への影響
- **Django**: Python製フレームワークの再評価
- **研究分野**: R → Python への移行加速

## AR/VR とクロスプラットフォーム（2016-2017年）

### Pokémon GO の衝撃
- **開発**: Niantic（元Google）
- **技術基盤**: Unity + C#
- **影響**: AR/VR技術への注目、Unity の再評価

### クロスプラットフォーム戦争
- **React Native**: Facebook
- **Flutter**: Google + Dart
- **結果**: Dart の復活、「学ぶ価値がない」からの大逆転

## 現代の開発環境（2018年以降）

### ノーコード/ローコード
- **背景**: アプリ開発のパターン化、難易度低下
- **対象**: 非プログラマーによるアプリ開発

### 言語の有償化議論
- **Oracle**: Sun買収後のJava有償化騒動
- **実際**: 無料利用は継続可能だが一部混乱

### 次世代言語の模索
- **Julia**: Python代替を狙う科学計算特化
- **量子コンピュータ**: Qiskit（IBM）、Cirq（Google）

## コロナ禍とプログラミング教育（2019-2022年）

### リモートワーク普及
- **影響**: プログラミング学習者の急増
- **副業**: プログラミングとの相性の良さ

### 義務教育化（日本）
- **教材**: Scratch（ビジュアルプログラミング）
- **実用言語**: Python が主流

### ゲーミフィケーション
- **任天堂**: 「ナビつき つくってわかる はじめてゲームプログラミング」
- **意義**: プログラミングの遊び文化としての位置づけ

## 生成AI時代の到来（2022年以降）

### ChatGPT の衝撃
- **OpenAI**: イーロン・マスク退任後の躍進
- **能力**: コード生成、プログラミング支援
- **影響**: プログラミング学習・開発手法の変化

### AI開発競争の激化
- **Mojo**: クリス・ラトナー（Swift作者）による AI 特化言語
- **背景**: AI開発戦争の新たなフェーズ

## まとめ：プログラミング言語史の教訓

### 技術決定要因
1. **社会的需要**: 戦争、経済活動、通信の必要性
2. **技術的革新**: ハードウェアの進歩、新しいパラダイム
3. **企業戦略**: プラットフォーム戦争、標準化競争
4. **開発者体験**: 生産性、学習コスト、楽しさ

### 成功する言語の特徴
1. **明確な問題解決**: 既存言語では困難な課題への対応
2. **適切なタイミング**: 技術的・社会的環境の準備
3. **エコシステム**: ツール、ライブラリ、コミュニティ
4. **継続的進化**: 時代に合わせた改良・拡張

### 未来への示唆
- プログラミング言語は目的達成のための道具
- 歴史を知ることで真の目的が見えてくる
- 技術選択は背景を理解して行うべき
- 大きな変革期には新しい言語が生まれる可能性

**あなたが使う言語の歴史を振り返り、その背景にある「なぜ」を理解することで、より良い技術選択ができるようになるでしょう。**